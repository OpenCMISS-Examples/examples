global a = 1.0;
global b = 1.0;
global c = 1.0;
global D = 1.0;
global E = 1.0;

global L = 3;

global ne = 100;

global np = ne+1;

global theta = 0.5;

global deltat = 0.0001;
global startt = 0.0;
global stopt = 0.01

global x = zeros(np,1);
global alpha = zeros(np,1);

global K = zeros(np,np);
global C = zeros(np,np);

K1 = ne/L;
K2 = -2*ne/L;
C1 = L/(6*ne);
C2 = (2*L)/(3*ne);

x(1) = 0.0;
alpha(1) = 0.0;

K(1,1) = K2/2;
K(1,2) = K1;

C(1,1) = C2/2;
C(1,2) = C1;

for i = 2:np-1

  x(i) = (i-1)*L/ne;
  alpha(i) = 0.0;

  K(i,i-1) = K1;
  K(i,i) = K2;
  K(i,i+1) = K1;

  C(i,i-1) = C1;
  C(i,i) = C2;
  C(i,i+1) = C1;
    
endfor

x(np) = L;
alpha(np) = 0.0;

K(np,np-1) = K1;
K(np,np) = K2/2;

C(np,np-1) = C1;
C(np,np) = C2/2;

global t = startt;

global analyticu = (D+a*x)/(E+c*t);

x

alpha

K

C

function y = g ( myu )

   global c;
   global np;

   y = zeros(np,1);
  
   y(1)=c/6.0*(myu(2)*myu(2)+myu(1)*myu(2)-2*myu(1)*myu(1));

   for i = 2:np-1

     y(i)= c/6.0*(2*myu(i+1)*myu(i+1)+myu(i-1)*myu(i)-myu(i)*myu(i+1)-2*myu(i-1)*myu(i-1));

   endfor
   
   y(np) = c/6.0*(2*myu(np)*myu(np)-myu(np-1)*myu(np)-myu(np-1)*myu(np-1));

endfunction 

function J = delgdelu ( myu )

   global c;
   global np;

   J = zeros(np,np);
   
   J(1,1) = c/6.0*(myu(2)-4*myu(1));
   J(1,2) = c/6.0*(2*myu(2)+myu(1));

   for i = 2:np-1

     J(i,i-1) = c/6.0*(-myu(i)-2*myu(i-1));
     J(i,i) = c/6.0*(myu(i+1)-myu(i-1));
     J(i,i+1) = c/6.0*(2*myu(i+1)+myu(i));

   endfor

   J(np,np-1) = c/6.0*(-myu(np)-2*myu(np-1));
   J(np,np) = c/6.0*(4*myu(np)-myu(np-1));

endfunction

function y = newg ( myalpha )
  
   global predictedu;
   global deltat;

   newu = predictedu + deltat*myalpha;

   y = g( newu );

endfunction 

function r = residual ( myalpha )

   global A;
   global prevg;
   global b;
   global theta;

   r = A*myalpha + theta*newg(myalpha) + (1-theta)*prevg + b;
	 
endfunction

function jacnewg = delnewgdelu ( alpha )

   global predictedu;
   global deltat;

   newu = predictedu + deltat*alpha;

   jacnewg = delgdelu ( newu );

endfunction

function J = Jacobian ( myalpha )

   global A;
   global theta;

   J = A + theta*delnewgdelu ( myalpha );

endfunction

function [reducedr,reducedJacobian] = reducedfunction ( reducedalpha )

   global alpha;
   global np;

   myalpha = zeros(np,1); 
  
   myalpha(1) = alpha(1);
   myalpha(2:np-1) = reducedalpha(1:np-2);
   myalpha(np) = alpha(np);

   r = residual ( myalpha );

   reducedr = r(2:np-1);

   if(nargout > 1)

      J = Jacobian ( myalpha );

      reducedJ = J(2:np-1,2:np-1);

   endif

endfunction

global A = C + theta*deltat*K;

cond(A)

quit

u = analyticu

currentg = g(u)

global prevu;
global prevg;
global meanpredictedu;
global predictedu;
global b;

while t < stopt

t = t + deltat

analyticu = (D+a*x)/(E+c*t)

prevu = u;
prevg = currentg;

alpha(1) = (analyticu(1)-u(1))/deltat;
alpha(np) = (analyticu(np)-u(np))/deltat;

meanpredictedu = u;

predictedu = u;

b = K*meanpredictedu;

startalpha = zeros(np-2,1);

[reducedalpha, fval, info] = fsolve( @reducedfunction, startalpha );

alpha(2:np-1) = reducedalpha;

u = predictedu + deltat*alpha

error = zeros(np,1);

for i = 1:np

  error(i) = 100.0*(u(i)-analyticu(i))/analyticu(i);

endfor

error

currentg = g( u );

analyticg = g( analyticu );

psi = A*alpha + theta*currentg + (1-theta)*prevg + b;

v = (u - prevu)/deltat;

analyticv = -c*(D+a*x)/((E+c*t)*(E+c*t));

resid = C*v + K*u + currentg

analyticresid =  C*analyticv + K*analyticu + analyticg;

endwhile
